import { EmbedBuilder, SlashCommandBuilder } from 'discord.js';
import type { PrefixCommand, SlashCommand } from '../types/command.js';
import { getStore } from '../store/store.js';
import { readFileSync } from 'node:fs';
import path from 'node:path';

// v hunt - SƒÉn qu√°i 1 l·∫ßn

// /hunt - Slash command handler
export const slashHunt: SlashCommand = {
  data: new SlashCommandBuilder()
    .setName('hunt')
    .setDescription('SƒÉn qu√°i th·∫ßn tho·∫°i (cooldown 2 ph√∫t)'),
  async execute(interaction) {
    try {
      const store = getStore();
      const cooldownCheck = store.checkCooldown(interaction.user.id, 'hunt');
      
      if (!cooldownCheck.canUse) {
        await interaction.reply({ content: `‚è∞ B·∫°n c·∫ßn ch·ªù ${cooldownCheck.remainingMinutes} ph√∫t n·ªØa m·ªõi c√≥ th·ªÉ sƒÉn qu√°i.`, ephemeral: true });
        return;
      }
      
      const user = store.getUser(interaction.user.id);
      const gameConfig = JSON.parse(readFileSync(path.join(process.cwd(), 'data/game_config.json'), 'utf8'));
      
      // L·ªçc monsters theo level
      const availableMonsters = Object.entries(gameConfig.monsters)
        .filter(([_, config]: [string, any]) => user.level >= config.levelRequired);
      
      if (availableMonsters.length === 0) {
        await interaction.reply({ content: 'B·∫°n c·∫ßn level cao h∆°n ƒë·ªÉ sƒÉn qu√°i.', ephemeral: true });
        return;
      }
      
      // T√≠nh t·ª∑ l·ªá th√†nh c√¥ng v·ªõi weapon bonus
      let baseSuccessRate = 0;
      let monsterName = '';
      let monsterEmoji = '';
      let monsterReward = { min: 0, max: 0 };
      let monsterLoot = '';
      
      // Ch·ªçn monster ng·∫´u nhi√™n
      const [monsterId, monsterConfig] = availableMonsters[Math.floor(Math.random() * availableMonsters.length)];
      monsterName = (monsterConfig as any).name;
      monsterEmoji = (monsterConfig as any).emoji;
      monsterReward = (monsterConfig as any).reward;
      monsterLoot = (monsterConfig as any).loot;
      baseSuccessRate = (monsterConfig as any).successRate;
      
      // Weapon bonus
      let weaponBonus = 0;
      if (user.equippedItems.weapon) {
        const weaponId = user.equippedItems.weapon;
        const weaponBonusData = gameConfig.weapon_bonuses[weaponId];
        if (weaponBonusData) {
          weaponBonus = weaponBonusData;
        }
      }
      
      const finalSuccessRate = Math.min(95, baseSuccessRate + weaponBonus);
      const isSuccess = Math.random() * 100 < finalSuccessRate;
      
      if (isSuccess) {
        // Th√†nh c√¥ng
        const reward = monsterReward.min + Math.floor(Math.random() * (monsterReward.max - monsterReward.min + 1));
        let finalReward = reward;
        
        // D√©p T·ªï Ong bonus
        if (user.equippedItems.weapon === 'dep_to_ong') {
          finalReward = Math.floor(reward * 1.5);
        }
        
        user.balance += finalReward;
        store.addItemToInventory(interaction.user.id, 'monsterItems', monsterLoot, 1);
        store.setCooldown(interaction.user.id, 'hunt', 2);
        store.addXP(interaction.user.id, 5);
        store.save();
        
        const embed = new EmbedBuilder()
          .setTitle('‚öîÔ∏è SƒÉn qu√°i th√†nh c√¥ng!')
          .setColor('#4fc3f7')
          .addFields(
            { name: 'Qu√°i v·∫≠t', value: `${monsterEmoji} ${monsterName}`, inline: true },
            { name: 'Ph·∫ßn th∆∞·ªüng', value: `${finalReward} V`, inline: true },
            { name: 'Loot', value: `${monsterLoot}`, inline: true }
          )
          .setTimestamp();
        
        if (user.equippedItems.weapon === 'dep_to_ong') {
          embed.addFields({ name: 'üèÜ D√©p T·ªï Ong Bonus', value: '+50% V reward', inline: false });
        }
        
        await interaction.reply({ embeds: [embed] });
      } else {
        // Th·∫•t b·∫°i
        store.setCooldown(interaction.user.id, 'hunt', 2);
        store.save();
        
        const embed = new EmbedBuilder()
          .setTitle('üíÄ SƒÉn qu√°i th·∫•t b·∫°i!')
          .setColor('#f44336')
          .addFields(
            { name: 'Qu√°i v·∫≠t', value: `${monsterEmoji} ${monsterName}`, inline: true },
            { name: 'K·∫øt qu·∫£', value: 'Qu√°i v·∫≠t ƒë√£ tr·ªën tho√°t!', inline: true },
            { name: 'T·ª∑ l·ªá th√†nh c√¥ng', value: `${finalSuccessRate}%`, inline: true }
          )
          .setTimestamp();
        
        await interaction.reply({ embeds: [embed] });
      }
    } catch (error) {
      console.error('Error in slashHunt:', error);
      if (!interaction.replied && !interaction.deferred) {
        await interaction.reply({ content: 'C√≥ l·ªói x·∫£y ra khi sƒÉn qu√°i.', ephemeral: true });
      }
    }
  }
};

export const prefixHunt: PrefixCommand = {
  name: 'hunt',
  description: 'SƒÉn qu√°i th·∫ßn tho·∫°i (cooldown 2 ph√∫t)',
  async execute(message) {
    const store = getStore();
    const cooldownCheck = store.checkCooldown(message.author.id, 'hunt');
    
    if (!cooldownCheck.canUse) {
      await message.reply(`‚è∞ B·∫°n c·∫ßn ch·ªù ${cooldownCheck.remainingMinutes} ph√∫t n·ªØa m·ªõi c√≥ th·ªÉ sƒÉn qu√°i.`);
      return;
    }
    
    const user = store.getUser(message.author.id);
    const gameConfig = JSON.parse(readFileSync(path.join(process.cwd(), 'data/game_config.json'), 'utf8'));
    
    // L·ªçc monsters theo level
    const availableMonsters = Object.entries(gameConfig.monsters)
      .filter(([_, config]: [string, any]) => user.level >= config.levelRequired);
    
    if (availableMonsters.length === 0) {
      await message.reply('B·∫°n c·∫ßn level cao h∆°n ƒë·ªÉ sƒÉn qu√°i.');
      return;
    }
    
    // T√≠nh t·ª∑ l·ªá th√†nh c√¥ng v·ªõi weapon bonus
    let baseSuccessRate = 0;
    let monsterName = '';
    let monsterEmoji = '';
    let monsterReward = { min: 0, max: 0 };
    let monsterLoot = '';
    
    // Random monster d·ª±a tr√™n level
    const randomMonster = availableMonsters[Math.floor(Math.random() * availableMonsters.length)];
    const [monsterKey, monsterConfig] = randomMonster as [string, any];
    baseSuccessRate = monsterConfig.successRate;
    monsterName = monsterConfig.name;
    monsterEmoji = monsterConfig.emoji;
    monsterReward = monsterConfig.reward;
    monsterLoot = monsterConfig.loot;
    
    // √Åp d·ª•ng weapon bonus
    if (user.equippedItems.weapon) {
      const weaponBonus = gameConfig.weapon_bonuses[user.equippedItems.weapon] || 0;
      baseSuccessRate += weaponBonus;
    }
    
    // √Åp d·ª•ng lucky charm n·∫øu c√≥
    const hasLuckyCharm = store.getItemQuantity(message.author.id, 'monsterItems', 'lucky_charm') > 0;
    if (hasLuckyCharm) {
      baseSuccessRate += 20; // +20% v·ªõi lucky charm
      store.removeItemFromInventory(message.author.id, 'monsterItems', 'lucky_charm', 1);
    }
    
    // Th·ª±c hi·ªán sƒÉn qu√°i
    const success = Math.random() * 100 < baseSuccessRate;
    let reward = 0;
    let lootMessage = '';
    
    if (success) {
      // Random KG t·ª´ 1 - 100 KG
      const kg = Math.floor(1 + Math.random() * 100);
      
      // T√≠nh reward
      reward = monsterReward.min + Math.floor(Math.random() * (monsterReward.max - monsterReward.min + 1));
      
      // üèÜ BONUS ƒê·∫∂C BI·ªÜT: D√©p T·ªï Ong tƒÉng 50% V reward
      let finalReward = reward;
      if (user.equippedItems.weapon === 'dep_to_ong') {
        const depBonus = Math.floor(reward * 0.5); // +50% V reward
        finalReward += depBonus;
      }
      
      // √Åp d·ª•ng guild rank buff
      const userGuild = store.getUserGuild(message.author.id);
      if (userGuild) {
        const buffs = store.getGuildRankBuffs(userGuild.guildRank.level);
        const bonus = Math.floor(finalReward * buffs.incomeBonus / 100);
        finalReward += bonus;
      }
      
      user.balance += finalReward;
      
      // Th√™m loot v√†o inventory
      store.addItemToInventory(message.author.id, 'monsterItems', monsterLoot, 1);
      
      let bonusMessage = '';
      if (user.equippedItems.weapon === 'dep_to_ong') {
        bonusMessage = `\nüèÜ D√©p T·ªï Ong bonus: +${Math.floor(reward * 0.5)} V`;
      }
      lootMessage = `\nüí∞ +${finalReward} V${bonusMessage}\nüëª +1 ${monsterLoot} (${kg} KG)`;
    }
    
    // Set cooldown
    store.setCooldown(message.author.id, 'hunt', 2);
    
    // C·ªông XP
    const xpResult = store.addXP(message.author.id, 15);
    store.save();
    
    // L·∫•y th√¥ng tin guild
    const userGuild = store.getUserGuild(message.author.id);
    
    const embed = new EmbedBuilder()
      .setTitle('‚öîÔ∏è SƒÉn Qu√°i')
      .setColor(success ? '#1a237e' : '#ff6f00')
      .addFields(
        { name: 'üéØ M·ª•c ti√™u', value: `${monsterEmoji} ${monsterName}`, inline: true },
        { name: 'üìä T·ª∑ l·ªá th√†nh c√¥ng', value: `${Math.round(baseSuccessRate)}%`, inline: true },
        { name: '‚öîÔ∏è V≈© kh√≠', value: user.equippedItems.weapon || 'Kh√¥ng c√≥', inline: true },
        { name: 'üé≤ K·∫øt qu·∫£', value: success ? '‚úÖ Th√†nh c√¥ng!' : '‚ùå Th·∫•t b·∫°i!', inline: false }
      )
      .setTimestamp();
    
    if (success) {
      embed.addFields({ name: 'üéÅ Ph·∫ßn th∆∞·ªüng', value: lootMessage, inline: false });
    }
    
    if (userGuild) {
      const buffs = store.getGuildRankBuffs(userGuild.guildRank.level);
      embed.addFields({ name: 'üèÜ Guild Bonus', value: `+${buffs.incomeBonus}% thu nh·∫≠p`, inline: false });
    }
    
    embed.addFields({ name: 'üéØ XP', value: xpResult.message, inline: false });
    
    await message.reply({ embeds: [embed] });
  }
};

// v hunt equip <t√™n_v≈©_kh√≠> - Trang b·ªã v≈© kh√≠
export const prefixHuntEquip: PrefixCommand = {
  name: 'hunt_equip',
  description: 'Trang b·ªã v≈© kh√≠ sƒÉn qu√°i',
  async execute(message, args) {
    const weaponName = args[0];
    if (!weaponName) {
      await message.reply('C√∫ ph√°p: v hunt equip <t√™n_v≈©_kh√≠>');
      return;
    }
    
    const store = getStore();
    const result = store.equipItem(message.author.id, 'weapon', weaponName);
    
    const embed = new EmbedBuilder()
      .setTitle('‚öîÔ∏è Trang B·ªã V≈© Kh√≠')
      .setColor(result.success ? '#00FF00' : '#FF0000')
      .setDescription(result.message)
      .setTimestamp();
    
    await message.reply({ embeds: [embed] });
  }
};

// v hunt inventory / v hunt inv - Xem ƒë·ªì sƒÉn qu√°i
export const prefixHuntInventory: PrefixCommand = {
  name: 'hunt_inventory',
  description: 'Xem ƒë·ªì sƒÉn qu√°i',
  async execute(message) {
    const store = getStore();
    const user = store.getUser(message.author.id);
    const monsterItems = user.categorizedInventory.monsterItems;
    const weapons = user.categorizedInventory.weapons;
    
    const formatItems = (items: Record<string, number>, emoji: string) => {
      const entries = Object.entries(items);
      if (entries.length === 0) return `${emoji} Tr·ªëng`;
      return entries.map(([item, qty]) => `${emoji} ${item}: ${qty}`).join('\n');
    };
    
    const embed = new EmbedBuilder()
      .setTitle('‚öîÔ∏è ƒê·ªì SƒÉn Qu√°i')
      .setColor('#1a237e')
      .addFields(
        { name: '‚öîÔ∏è V≈© kh√≠', value: formatItems(weapons, '‚öîÔ∏è'), inline: true },
        { name: 'üëª Linh h·ªìn qu√°i', value: formatItems(monsterItems, 'üëª'), inline: true },
        { name: 'üéØ ƒêang trang b·ªã', value: user.equippedItems.weapon || 'Kh√¥ng c√≥', inline: true }
      )
      .setTimestamp();
    
    await message.reply({ embeds: [embed] });
  }
};

// v hunt use <t√™n_b√πa> - D√πng b√πa ph√©p
export const prefixHuntUse: PrefixCommand = {
  name: 'hunt_use',
  description: 'D√πng b√πa ph√©p tƒÉng t·ª∑ l·ªá sƒÉn qu√°i',
  async execute(message, args) {
    const itemName = args[0];
    if (!itemName) {
      await message.reply('C√∫ ph√°p: v hunt use <t√™n_b√πa>');
      return;
    }
    
    const store = getStore();
    const user = store.getUser(message.author.id);
    
    if (itemName === 'lucky_charm') {
      const hasCharm = store.getItemQuantity(message.author.id, 'monsterItems', 'lucky_charm') > 0;
      if (!hasCharm) {
        await message.reply('B·∫°n kh√¥ng c√≥ lucky charm.');
        return;
      }
      
      // Lucky charm s·∫Ω ƒë∆∞·ª£c d√πng t·ª± ƒë·ªông khi hunt
      await message.reply('üçÄ Lucky charm ƒë√£ ƒë∆∞·ª£c k√≠ch ho·∫°t! S·∫Ω ƒë∆∞·ª£c d√πng trong l·∫ßn sƒÉn ti·∫øp theo.');
      return;
    }
    
    await message.reply('Ch·ªâ c√≥ th·ªÉ d√πng lucky_charm.');
  }
};

// Main hunt command handler
export const prefixHuntMain: PrefixCommand = {
  name: 'hunt',
  description: 'SƒÉn b·∫Øn: hunt/equip/inventory/use',
  async execute(message, args) {
    const subcommand = args[0]?.toLowerCase();
    
    if (subcommand === 'equip') {
      await prefixHuntEquip.execute(message, args.slice(1));
    } else if (subcommand === 'inventory' || subcommand === 'inv') {
      await prefixHuntInventory.execute(message, []);
    } else if (subcommand === 'use') {
      await prefixHuntUse.execute(message, args.slice(1));
    } else {
      // Default: hunt
      await prefixHunt.execute(message, []);
    }
  }
};

export const prefixes: PrefixCommand[] = [prefixHuntMain];
